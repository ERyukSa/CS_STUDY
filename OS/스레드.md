# 본문에 앞서

## 1. 프로세스란?

- 운영체제에 의해 메모리 공간을 할당받아 실행중인 프로그램

- 하나의 프로세스는 Code, Data, Stack, Heap 영역으로 구성되어 있다

## 2. 복잡한 응용프로그램의 등장

- 애플리케이션은 여러개의 task로 이루어져 있다

- 애플리케이션의 구동 시간을 줄이려면 각각의 task를 동시에 실행하면 된다!

 
----------------------------

# 본문

## 스레드란?

- 스레드는 스레드 ID, PC, 레지스터 집합, Stack으로 구성된다.

- 프로세스가 OS에서 자원을 할당받는 작업의 단위라면, 스레드는 할당받은 자원을 이용하는 실행의 단위이다.

- 한 프로세스 내의 스레드 간에는 코드, 데이터, 파일 등 기타 자원을 공유하며, 각각의 스레드는 독립적인 Stack 영역과 레지스터를 가진다.

> - 각자 Stack을 가지고 있으면 독립적으로 함수를 호출할 수 있다
👉 독립적으로 실행 가능
- 스레드에서도 일정 시간 이후 문맥 교환이 발생하므로 독립적으로 PC 레지스터가 필요하다


## 스레드 개수에 따른 분류

### 1. 싱글 스레드 프로세스

- 하나의 프로세스에서 하나의 스레드가 존재

- 하나의 레지스터와 스택으로 표현 가능

### 2. 멀티 스레드 프로세스

- 다수의 실행 단위로 나누어 실행되는 프로세스

- 프로세스 내에서 자원을 공유하여 자원 생성과 관리의 중
복을 최소화

- 서버가 많은 요청을 효율적으로 수행할 수 있는 환경 제공

- 각각의 스레드가 독립적인 레지스터와 스택으로 구성됨

### 3. 싱글 스레드 모델의 장단점

장점 1) 자원 접근에 대한 동기화를 신경쓰지 않아도 된다

- 자원을 공유하는 여러개의 스레드를 사용할 때는 공용 자원에 대한 접근 통제가 적절히 이루어져야 한다.
    
장점 2) 문맥 교환을 하지 않는다

단점 1) 여러 개의 cpu를 활용하지 못한다

> - 단일 스레드 모델은 요청에 대한 빠른 반응을 요구하는 네트워크 서버의 프로그램에 적합하다
- 단순히 cpu만을 사용하는 계산 작업에서는 싱글 스레드로 프로그래밍하는 것이 더 효율적이다 

### 4. 멀티 스레드 모델의 장단점

장점 1) 새로운 프로세스의 생성보다 기존 프로세스에서 새로운 스레드를 생성하는 것이 빠르다

장점 2) 프로세스의 자원과 상태를 공유하여 효율적으로 운영이 가능하다

장점 3) 스레드의 문맥교환이 프로세스의 문맥교환보다 빠르다

단점 1) 하나의 스레드만 실행중인 경우 실행시간이 오히려 지연될 수 있다

단점 2) 멀티 스레딩을 위해서는 OS의 지원이 필요하다

단점 3) 스레드 스케줄링을 신경써야 한다

> 다양한 요인이 결합된 데이터를 이용하는 통계적 분석 연산의 경우(GPU 사용), 멀티 스레드 모델이 더 적합하다 

## 생성(스케줄링) 주체에 따른 분류

### 1. 커널 수준 스레드 (Pure Kernel-Level)

- 커널이 스레드의 생성 및 스케줄링 등을 관리하므로 커널 영역에서 스레드 연산을 수행하며, 커널에 종속적이다

- 커널 스레드는 가장 가벼운 커널 스케줄링 단위이다

- 사용자 수준 스레드와 커널 수준 스레드가 1:1로 매핑되므로, 사용자 수준 스레드를 사용하면 이에 대응되는 커널 스레드는 자동으로 생성된다

![커널 수준 스레드](https://images.velog.io/images/hahahaa8642/post/5540bbcb-fa9a-4e06-a948-cdaed5fbbc0a/kernel%20thread.png)

#### 장점

- 프로세스의 스레드들을 몇몇 프로세서에 한꺼번에 디스패치 할 수 있기 때문에 멀티프로세서 환경에서 매우 빠르게 동작한다

- 커널이 스레드를 개별적으로 관리하므로 병렬적으로 수행이 가능하며, 하나의 스레드의 입출력 작업이 수행될 때에도 다른 스레드의 작업에는 지장이 없다

#### 단점

- 스케줄링과 동기화를 위해 커널을 호출하는데 무겁고 오래 걸린다 (저장한 내용을 다시 불러오는 과정 필요)

- 즉, 사용자 모드에서 커널 모드로의 전환이 빈번하게 이루어져 성능 저하가 발생한다

- 사용자가 프로그래밍할 때 구현하기 어렵고 자원을 더 많이 소비하는 경향이 있다

### 2. 사용자 수준 스레드 (Pure User-Level)

- 일반적으로 사용자 수준의 라이브러리를 통해 구현되므로 사용자 영역에서 스레드 연산을 수행한다

- 커널은 스레드의 존재를 인식하지 못해 커널의 개입을 받지 않으므로 운영체제에 투명하다

- 다수의 사용자 수준 스레드가 커널 수준 스레드 한개에 매핑되므로 다대일 스레드 매핑이라고 한다

![사용자 수준 스레드](https://images.velog.io/images/hahahaa8642/post/dcbeb8d0-2c42-42db-8a8c-19fa0e49a03b/thread.png)

#### 장점

- 운영체제에서 스레드를 지원할 필요가 없으며 모드간의 전환 없이 사용자 영역에서 생성 및 관리되므로 속도가 빠르다

- 스케줄링 결정이나 동기화를 위해 커널을 호출하지 않기 때문에 인터럽트가 발생할 때 커널 레벨 스레드보다 오버헤드가 적다. 즉, OS scheduler의 context switch가 없다. (user level thread scheduler를 이용한다)

- 커널의 개입을 받지 않으므로 이식성(portability)이 높다. (모든 운영체제에서 실행 가능)

#### 단점

- 시스템 전반에 걸친 스케줄링 우선순위를 지원하지 않는다. (무슨 스레드가 먼저 동작할 지 모른다)

- 커널에서는 스레드가 하나라고 인식하기 때문에, 하나의 스레드가 I/O 작업 등에 의해 block되면 같은 프로세스 내의 모든 스레드가 block된다


### 3. 혼합 스레드 (Combined)

- 위의 두가지 방식을 혼합하여 단점을 극복한 구조

- 사용자 수준 스레드는 커널 수준 스레드와 비슷한 경량 프로세스에 다대다로 매핑되고, 경량 프로세스는 커널 수준 스레드와 일대일로 매핑된다. 결국 다수의 사용자 수준 스레드에 다수의 커널 스레드가 다대다로 매핑된다

![혼합 스레드](https://images.velog.io/images/hahahaa8642/post/a2e170ba-939a-4b4b-8d1d-7e1ffbb91d9e/%ED%98%BC%ED%95%A9%ED%98%95.png)

- 프로세스 내 스레드들이 병렬적으로 수행 가능

- 스레드 풀링 기법을 통해 일대일 스레드 매핑에서의 오버헤드를 줄여줌


------------------

# 참고

[goodGid 님의 블로그](https://goodgid.github.io/What-is-Thread/)

[반짝반짝 빈나는 님의 블로그](https://beenlife.tistory.com/114)

[yoongrammer 님의 블로그](https://yoongrammer.tistory.com/55)

[crocus 님의 블로그](https://www.crocus.co.kr/1255)

[박연호 님의 블로그](https://kosaf04pyh.tistory.com/38)
